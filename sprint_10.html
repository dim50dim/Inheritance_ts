<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Sprint 10. Наследование в TS</title>
  <meta name="author" content="itgid.info">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@300;400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/skeleton.css">
  <link rel="stylesheet" href="css/style.css">
  <!-- <link rel="stylesheet" href="css/night.css"> -->
  <link rel="icon" type="image/svg+xml" href="https://itgid.info/favicon.svg">
</head>

<body>
  <div class="container">
    <div class="row">
      <div class="one-column">
        <h1>TypeScript. Sprint 10</h1>
        <h2>Наследование в TypeScript</h2>
        <p>course <a href="https://itgid.info">itgid.info</a></p>

        <p>Для применения темы "ночь" удалите комментарий с night.css. </p>
        <p>Условие: везде где не сказано о способе задания типа данных - тип задается явно.</p>

        <section>
          <h3>Task 01</h3>
          <p>Создан класс Test_00, который не делает ничего полезного, на нем мы отработаем базовые возможности наследования. Итак, создайте класс Test_01, который наследуется от Test_00. Выведите в консоль Test_01. Убедитесь, что в классе Test_01 доступно свойство data.</p>
        </section>

        <section>
          <h3>Task 02</h3>
          <p>Наследуйтесь от класса Test_00, создайте класс Test_02, добавьте в него свойство title, равное 'class 02'. Создайте объект на основе класса Test_02 и выведите в консоль. Убедитесь что объект содержит свойства класса Test_00 и Test_02.</p>
        </section>

        <section>
          <h3>Task 03</h3>
          <p>Создайте класс Test_03, которій наследуется от класса Test_02 и добавляет метод showData(), который содержит одну строку console.log(this.data, this.title). Создайте объект и убедитесь, что метод работает.</p>
        </section>

        <section>
          <h3>Task 04</h3>
          <p>Наследуйтесь от класса Test_03 создайте класс Test_04. Добавьте функцию конструктор, которая принимает два текстовых параметра и задает с помощью них значения this.data и this.title. Не забывайте, если вы переписываете, создаете заново функцию конструктор, то обязаны вызывать super().</p>
        </section>

        <section>
          <h3>Task 05</h3>
          <p> Итак, мы можем наследоваться и добавлять в наследуемые классы и свойства и методы и даже метод конструктор. Добавлять методы можно двумя способами - просто полной перезаписью метода, либо (второй способ) - дополнением. Давайте рассмотрим метод полной перезаписи. Посмотрите на класс M_00. Он содержит метод goMath(). Создадим класс M_05, который наследуется от M_00 и полностью перезаписывает метод goMath() следующим кодом: return this.a * this.b; 
            // Обратите внимание - тут не нужен super().</p>

        </section>

        <section>
          <h3>Task 06</h3>
          <p>В предыдущем примере мы перезаписали метод полностью. Теперь - давайте дополним и расширим существующий метод. Поскольку в классе M_00 метод возвращает значение (return), то сделаем следующее... Создайте класс M_06 расширяющий M_00. Напишите ему метод goMath, со следующим кодом:
            // const n = super.goMath();
            // return n % 2 === 0 ? 1 : 0;
            // т.е. строкой n = super.goMath() мы выполняем код из метода родителя (суммируем числа), а в данном методе проверяем является ли число четным.</p>
        </section>

        <section>
          <h3>Task 07</h3>
          <p>Обратите внимание, метод goMath() в классе M_06 был бы логичнее если бы возвращал значение true, false. Однако тогда мы нарушаем идеологию наследования и ООП. Т.е. мы изменяем в принципе метод, тип данных и т.д. В таком случае правильнее сделать новый метод, который и будет реализовывать данное поведение. Создайте класс M_07, который наследуется от M_00 и содержит метод isEven с кодом:</p>
          <pre><code>
const n = super.goMath();
return n % 2 === 0;
          </code></pre>
           
            <p>Проверьте роботу. Я надеюсь, что и в предыдущем и в текущих заданиях вы не забываете указывать тип данных, который возвращает метод.</p>
        </section>

        <section>
          <h3>Task 08</h3>
          <p>Итак, мы разобрались с наследованием методов. Давайте разберемся с конструктором. Пусть есть класс P_00. Он содержит одной свойство и конструктор. Напишите класс P_08, который наследуется от P_00 и добавляет свойство b : number. Также расширьте функцию конструктор, который принимает два числа, одно через super посылает в конструктор родителя, второе задает свойству b.</p>
        </section>
        </section>

        <section>
          <h3>Task 09</h3>
          <p>Создайте класс наследник P_09 для класса P_08. В классе  P_09 добавьте свойство sum равное нулю. Добавьте метод mathSum(), который суммирует this.a и this.b  и кладет результат в this.sum. </p>
        </section>

        <section>
          <h3>Task 10</h3>
          <p>Создайте класс P_10 как наследника P_09. Добавьте метод isSumEven, который возвращает true если сумма - четная и false в остальных случаях. </p>
        </section>


        <section>
          <h3>Task 11</h3>
          <p>Теперь перейдем к более интересным вещам. Давайте пройдемся по базовым примерам фронтенда. Создайте класс U_01, который содержит свойства username, email, status (число, по умолчанию 0), password. Поля username, email, password заполняются через конструктор.</p>
        </section>

        <section>
          <h3>Task 12</h3>
          <p>Создайте класс U_02, который наследуется от U_01. Допишите метод prepare(), который получает аргумент s (строку), обрезает пробелы и переводит текст в нижний регистр, возвращая результат.</p>
        </section>

        <section>
          <h3>Task 13</h3>
          <p>Создайте класс U_03, наследуйтесь от класса U_02, и допишите свойство isPasswordCorrect (по умолчанию false) и метод validatePassword, который делает следующее:</p>
          <ul>
            <li>Удаляет пробелы по краям пароля. </li>
            <li>Проверяет длину пароля. Если длина меньше 8 символов, то выставляет this.isPasswordCorrect равным false и возвращает false.</li>
            <li>Проверяет что в пароле есть символы в разных регистрах - если нет то  выставляет this.isPasswordCorrect равным false и возвращает false.</li>
          </ul>
          <p>Eсли проверки пройдены то выставляет this.isPasswordCorrect равным true и возвращает true.</p>

        </section>

        <section>
          <h3>Task 14</h3>
          <p>Создайте класс U_04 который наследуется от U_03 и добавьте в него свойство isEmailCorrect равное false. Напишите метод validateEmail, который валидирует емейл. Если валидация не пройдена, то isEmailCorrect ставится как false, и возвращается false. Если пройдена, то isEmailCorrect ставится как true, и возвращается true. Перед валидацией email примените к свойству this.email метод prepare. Т.е. измените само свойство this.email.</p>
        </section>

        <section>
          <h3>Task 15</h3>
          <p>Создайте класс U_05, наследуйтесь от U_04. Добавьте в класс свойство isUserValid, равный false. Добавьте метод validateUser, который выполняет валидацию eмайл и пароля. Если обе валидации true, и имя пользователя не пустая строка, то ставит isUserValid равное true и возвращает true. В противном случае false. </p>


        </section>

      </div>

      <div class="one-column">
        <footer>
          <p>Курсы Itgid.info</p>
          <p><a href="https://itgid.info/ru/course/js20">javascript 2.0</a> | <a
              href="https://itgid.info/ru/course/arraymethod">Методы массивов JavaScript</a> | <a
              href="https://itgid.info/ru/course/function-2021">Функции JavaScript</a> | <a
              href="https://itgid.info/ru/course/reactjs">ReactJS</a></p>
        </footer>
      </div>
    </div>
  </div>

  <script src="./javascript/sprint_10.js"></script>
</body>

</html>